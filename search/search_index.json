{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started \u00b6 KTracer is a Kotlin library that provides a simple tool for Ray Tracing. Learn how to use it in 5 minutes and begin to have fun, freeing your creativity! Installation \u00b6 binary \u00b6 You can download the latest stable binary distribution here . with git \u00b6 You may also want to clone the repository, in order to have all the latest updates. KTracer is built on gradle , so its installation is required for this installation procedure. You can install it here . If you have gradle installed, just run the command: git clone git@github.com:AnnaPivetta/KTracer.git When cloning from git , we recommend testing the success of the download with: ./gradlew test If everything is fine, you can build your own distribution with: ./gradlew assembleDist","title":"Installation"},{"location":"#getting-started","text":"KTracer is a Kotlin library that provides a simple tool for Ray Tracing. Learn how to use it in 5 minutes and begin to have fun, freeing your creativity!","title":"Getting started"},{"location":"#installation","text":"","title":"Installation"},{"location":"#binary","text":"You can download the latest stable binary distribution here .","title":"binary"},{"location":"#with-git","text":"You may also want to clone the repository, in order to have all the latest updates. KTracer is built on gradle , so its installation is required for this installation procedure. You can install it here . If you have gradle installed, just run the command: git clone git@github.com:AnnaPivetta/KTracer.git When cloning from git , we recommend testing the success of the download with: ./gradlew test If everything is fine, you can build your own distribution with: ./gradlew assembleDist","title":"with git"},{"location":"CHANGELOG/","text":"KTracer \u00b6 v1.1.0 _ August 28, 2021 \u00b6 New 16 : New Pigments are available, thanks to Pocedural Texturing. Being more specific new Marble, Wood and Lava style pigment can be added to every shape. New 19 : Shapes variable can be defined in the input file. In this way complicated objects may be defined with a name, created wherever is convenient, and then called back with the name and eventually transformed to be placed as desired. Follow tutorial 4 for more information v1.0.1 _ July 21, 2021 \u00b6 Fixed: bug in box (u,v) mapping v1.0.0 _ July 20, 2021 \u00b6 New #17 : Render mode is able to read input files API: Angles must be specified in degrees v0.2.1 _ June 10, 2021 \u00b6 New #12 : CSG objects can be transformed after their assembling New #14 : Box Texture has now changed the required format for Image Pigment. New shape Cylinder can be added to scenes v0.2.0 _ May 28, 2021 \u00b6 New #8 : Spheres can be added to the scene New #9 : The program can be run in different mode by command line and a demo can be created New #10 : Planes, boxes and CSG objects can be added to the scene New #11 : Uniform and checkered textures can be used and the objects surface can be defined ad diffusive or specular New #13 : Antialiasing algorithm can be applied in order to improve the image quality v0.1.1 _ May 5, 2021 \u00b6 Fix #6 : Computation of pixel position onto the screen v0.1.0 _ April 14, 2021 \u00b6 Reading PFM files Tone mapping Gamma correction Saving in LDR format. The list of available formats is here .","title":"Changelog"},{"location":"CHANGELOG/#ktracer","text":"","title":"KTracer"},{"location":"CHANGELOG/#v110-_-august-28-2021","text":"New 16 : New Pigments are available, thanks to Pocedural Texturing. Being more specific new Marble, Wood and Lava style pigment can be added to every shape. New 19 : Shapes variable can be defined in the input file. In this way complicated objects may be defined with a name, created wherever is convenient, and then called back with the name and eventually transformed to be placed as desired. Follow tutorial 4 for more information","title":"v1.1.0 _ August 28, 2021"},{"location":"CHANGELOG/#v101-_-july-21-2021","text":"Fixed: bug in box (u,v) mapping","title":"v1.0.1 _ July 21, 2021"},{"location":"CHANGELOG/#v100-_-july-20-2021","text":"New #17 : Render mode is able to read input files API: Angles must be specified in degrees","title":"v1.0.0 _ July 20, 2021"},{"location":"CHANGELOG/#v021-_-june-10-2021","text":"New #12 : CSG objects can be transformed after their assembling New #14 : Box Texture has now changed the required format for Image Pigment. New shape Cylinder can be added to scenes","title":"v0.2.1 _ June 10, 2021"},{"location":"CHANGELOG/#v020-_-may-28-2021","text":"New #8 : Spheres can be added to the scene New #9 : The program can be run in different mode by command line and a demo can be created New #10 : Planes, boxes and CSG objects can be added to the scene New #11 : Uniform and checkered textures can be used and the objects surface can be defined ad diffusive or specular New #13 : Antialiasing algorithm can be applied in order to improve the image quality","title":"v0.2.0 _ May 28, 2021"},{"location":"CHANGELOG/#v011-_-may-5-2021","text":"Fix #6 : Computation of pixel position onto the screen","title":"v0.1.1 _ May 5, 2021"},{"location":"CHANGELOG/#v010-_-april-14-2021","text":"Reading PFM files Tone mapping Gamma correction Saving in LDR format. The list of available formats is here .","title":"v0.1.0 _ April 14, 2021"},{"location":"basic-usage/","text":"Basic usage \u00b6 Demo mode \u00b6 Once installed your KTracer , the first and very simple image you may generate is a demo. Running the command: ./KTracer demo will render the image described in the file demo.txt , which by default is the following: Demo image shows some of KTracer capability Converter mode \u00b6 If you have run the demo , you may have notice that you have obtained 2 different files. A ldr image, the one showed above, and an hdr one. This second one is useful, as it contains the raw value of pixel color, without any tone mapping or gamma correction applied. If the luminosity of the image does not satisfy you and you want to correct it, with the pfm file it will be a child's play. Just run the command: ./KTracer pfm2ldr --input <FILE IN> --output <FILE OUT> --format <FORMAT> and set the parameters: - --luminosity <LUMINOSITY> The required average luminosity - --gamma <GAMMA> The gamma factor of the monitor - --factor <FACTOR> a rescaling factor for colors (if interested, you can find more details in Shirley&Morley ) Render mode \u00b6 If you are here for realistic image generation, this is by far the most interesting and fun mode you can choose. Once you'll learn how to produce the input file for setting the scene, this command will perform the magic: ./KTracer render --inputfile <FILE IN> Even though the inputfile is the only mandatory flag, there are quite a lot of other interesting features that may be activated while rendering an image. Some of the most useful parameters are: --width | -w <WIDTH> The width of the image --height | -h <HEIGTH> The height of the image --algorithm | -a <ALGORITHM> The algorithm used to render the image. See later for further information --ldr-o | --ldroutput <FILE OUT> The name of the LDR output file --nr | -n <NUMBER OF RAYS> Number of rays generated at each surface-ray interaction --maxDepth | -Md <NUMBER OF REFLECTIONS> Maximum number of reflections per ray --rrTrigger | -rr <TRIGGER> Depth value after which Russian Roulette algorithm activates. --AAgrid | --AA | --aa | -A <NUMBER> Number of divisions in each pixel's side to perform antialiasing (more simply, <NUMBER>*<NUMBER> is the total amount of samples per pixel) Animation \u00b6 With the help of ffmpeg also beautiful animations can be rendered with KTracer . On our repository there is a script to create animations. You must have a variable in the input file that is associated to the rotation of the camera, and using it you can create your own GIF .","title":"Basic Usage"},{"location":"basic-usage/#basic-usage","text":"","title":"Basic usage"},{"location":"basic-usage/#demo-mode","text":"Once installed your KTracer , the first and very simple image you may generate is a demo. Running the command: ./KTracer demo will render the image described in the file demo.txt , which by default is the following: Demo image shows some of KTracer capability","title":"Demo mode"},{"location":"basic-usage/#converter-mode","text":"If you have run the demo , you may have notice that you have obtained 2 different files. A ldr image, the one showed above, and an hdr one. This second one is useful, as it contains the raw value of pixel color, without any tone mapping or gamma correction applied. If the luminosity of the image does not satisfy you and you want to correct it, with the pfm file it will be a child's play. Just run the command: ./KTracer pfm2ldr --input <FILE IN> --output <FILE OUT> --format <FORMAT> and set the parameters: - --luminosity <LUMINOSITY> The required average luminosity - --gamma <GAMMA> The gamma factor of the monitor - --factor <FACTOR> a rescaling factor for colors (if interested, you can find more details in Shirley&Morley )","title":"Converter mode"},{"location":"basic-usage/#render-mode","text":"If you are here for realistic image generation, this is by far the most interesting and fun mode you can choose. Once you'll learn how to produce the input file for setting the scene, this command will perform the magic: ./KTracer render --inputfile <FILE IN> Even though the inputfile is the only mandatory flag, there are quite a lot of other interesting features that may be activated while rendering an image. Some of the most useful parameters are: --width | -w <WIDTH> The width of the image --height | -h <HEIGTH> The height of the image --algorithm | -a <ALGORITHM> The algorithm used to render the image. See later for further information --ldr-o | --ldroutput <FILE OUT> The name of the LDR output file --nr | -n <NUMBER OF RAYS> Number of rays generated at each surface-ray interaction --maxDepth | -Md <NUMBER OF REFLECTIONS> Maximum number of reflections per ray --rrTrigger | -rr <TRIGGER> Depth value after which Russian Roulette algorithm activates. --AAgrid | --AA | --aa | -A <NUMBER> Number of divisions in each pixel's side to perform antialiasing (more simply, <NUMBER>*<NUMBER> is the total amount of samples per pixel)","title":"Render mode"},{"location":"basic-usage/#animation","text":"With the help of ffmpeg also beautiful animations can be rendered with KTracer . On our repository there is a script to create animations. You must have a variable in the input file that is associated to the rotation of the camera, and using it you can create your own GIF .","title":"Animation"},{"location":"gallery/","text":"Images \u00b6 Here you can find some images that can be rendered with KTracer The classic benchmark of renderers, our Cornell Box Our logo A fancy use of CSG and image pigments A colorful image that shows some of the BRDFs and the pigments available, as well as basic shapes Another fancy use of CSG, for a comfortable sitting place Exploitation of specular BRDF","title":"Gallery"},{"location":"gallery/#images","text":"Here you can find some images that can be rendered with KTracer The classic benchmark of renderers, our Cornell Box Our logo A fancy use of CSG and image pigments A colorful image that shows some of the BRDFs and the pigments available, as well as basic shapes Another fancy use of CSG, for a comfortable sitting place Exploitation of specular BRDF","title":"Images"},{"location":"input-file/","text":"The scenes to render are described in an input file , which is the only mandatory parameter for Render mode . Input file is provided also with comments, identified by the key symbol # . The three main ingredients for a scene are: materials shapes camera Materials \u00b6 Each object in the scene must be made of a material, which is defined by its BRDF and its emitted radiance. Moreover, to each material you must assign a name with which you'll be able to call it all through the file. BRDF \u00b6 The BRDF describes the way the light interacts with the shape, once a ray hits it. The light can be scattered or reflected, and this behaviour affects the way we see the object. There are 2 different BRDF s available: Diffusive (Lambertian) \u00b6 Represents a completely diffusive material. When the light hits, it is scattered in random directions, thus making the object totally opaque. Specular \u00b6 As the name suggests, this BRDF describes a total reflecting surface, such as the one of an ideal mirror. When the light hits, the ray follows the law of reflection . Both BRDF s needs also a parameter: the color of the object, which is represented by a Pigment . Emitted Radiance \u00b6 Emitted radiance too is defined by a Pigment . This value is the color in which the objects, eventually, radiate. For diffusive objects, it is set as uniform(<black>) , but a different choice leads to creating a source of lights in the scene. It is always necessary to have at least one source of lights in order to see the scene. Here are two examples of different material definitions: Diffusive (radiating) material sky ( diffuse ( uniform(<skyblue>) ), uniform(<skyblue>) ) ... Specular (not radiating) material mirror ( specular ( uniform(<silver>) ), uniform(<black>) ) ... An image with both specular and diffusive BRDF Shapes \u00b6 After having defined the materials, it's now time to build the scene you want to render. This is made by placing the available shapes wherever you like, assigning them the material they're made of. Not only the material is important, but also transformations play great role in the setting of the stage. By default, each shape is placed with its center in the point (0.0, 0.0, 0.0) of the world and has a default dimension. Both position and dimension, along with also orientation in the space, can be modified by the means of a transformation. Transformations \u00b6 If no transformation need to be applied you can simply use the keyword identity , such as in the following example ... sphere ( sky, identity ) ... Translation \u00b6 To apply a solid translation to the selected shape the keyword is translation([vec]) , where the vector generating the transformation is [vec] = [x, y, z] , specified giving its three components between squared brackets ... sphere ( sky, translation([1.0, 2.0, 0.0]) ) ... Rotations \u00b6 Rotations are always with respect to one of the 3 principal axis. The angle of rotation is expressed in degrees, and the keyword is rotation_^ , where ^ is one of x , y or z , and is the axis along which the rotation occurs. Different basic transformation may be combined into a more complex one with the help of * operator. Since they are implemented as matrices, the order in which transformations are applied is from right to left. In the following example a cube is rotated with respect to the z axis and translated along the x axis by 1.0: ... box ( (-0.5, -0.5, -0.5), (0.5, 0.5, 0.5), minecraft, translation([1.0, 0.0, 0.0]) * rotation_z(30) ) ... On the left the cylinder has been first translated and then rotated. On the right the order of transformations is the opposite Scaling \u00b6 The third possible transformation is the one that changes the dimension of the object. The scaling does not have to be homogeneous and may vary along different directions. The keyword is scaling([vec]) , where [vec] components are the scale factor along each direction. ... sphere ( mirror, scaling([1.0, 3.0, 1.0]) ) ... Inhomogeneous scaling of a sphere leads to an ellipsoid Definitions \u00b6 One may also want to define a variable that represents a shape, so that this can be called multiple times in the input file with the use of a simple name. This is extremely useful in the creation of complex CSG shapes. The syntax is similar to the one used for defining materials, and to call the object in the file it is sufficient to write the name, and the transformation to apply: ... shape minecraftCube box ( #Defining the shape (-0.5, -0.5, -0.5), (0.5, 0.5, 0.5), minecraft, identity ) minecraftCube ( rotation_z(45) ) #Placing the shape into the world ... Camera \u00b6 The last ingredient, before rendering your first image, is a camera from which the world is observed. Cameras accept a transformation parameter that sets its position and orientation. It also need to know the aspect ratio of the image, and the distance from the camera and the scree onto which the scene is projected (recommended is 1.0). There are two different projections available: orthogonal and perspective Orthogonal ... camera( orthogonal, translation([-4,0,1]), 1.0, #Aspect Ratio 1.0 #Distance from screen ) Perspective ... camera( perspective, translation([-4,0,1]), 1.0, 1.0 ) Orthogonal VS Perspective projection. Camera is in the same position for both images","title":"Input File"},{"location":"input-file/#materials","text":"Each object in the scene must be made of a material, which is defined by its BRDF and its emitted radiance. Moreover, to each material you must assign a name with which you'll be able to call it all through the file.","title":"Materials"},{"location":"input-file/#brdf","text":"The BRDF describes the way the light interacts with the shape, once a ray hits it. The light can be scattered or reflected, and this behaviour affects the way we see the object. There are 2 different BRDF s available:","title":"BRDF"},{"location":"input-file/#diffusive-lambertian","text":"Represents a completely diffusive material. When the light hits, it is scattered in random directions, thus making the object totally opaque.","title":"Diffusive (Lambertian)"},{"location":"input-file/#specular","text":"As the name suggests, this BRDF describes a total reflecting surface, such as the one of an ideal mirror. When the light hits, the ray follows the law of reflection . Both BRDF s needs also a parameter: the color of the object, which is represented by a Pigment .","title":"Specular"},{"location":"input-file/#emitted-radiance","text":"Emitted radiance too is defined by a Pigment . This value is the color in which the objects, eventually, radiate. For diffusive objects, it is set as uniform(<black>) , but a different choice leads to creating a source of lights in the scene. It is always necessary to have at least one source of lights in order to see the scene. Here are two examples of different material definitions: Diffusive (radiating) material sky ( diffuse ( uniform(<skyblue>) ), uniform(<skyblue>) ) ... Specular (not radiating) material mirror ( specular ( uniform(<silver>) ), uniform(<black>) ) ... An image with both specular and diffusive BRDF","title":"Emitted Radiance"},{"location":"input-file/#shapes","text":"After having defined the materials, it's now time to build the scene you want to render. This is made by placing the available shapes wherever you like, assigning them the material they're made of. Not only the material is important, but also transformations play great role in the setting of the stage. By default, each shape is placed with its center in the point (0.0, 0.0, 0.0) of the world and has a default dimension. Both position and dimension, along with also orientation in the space, can be modified by the means of a transformation.","title":"Shapes"},{"location":"input-file/#transformations","text":"If no transformation need to be applied you can simply use the keyword identity , such as in the following example ... sphere ( sky, identity ) ...","title":"Transformations"},{"location":"input-file/#translation","text":"To apply a solid translation to the selected shape the keyword is translation([vec]) , where the vector generating the transformation is [vec] = [x, y, z] , specified giving its three components between squared brackets ... sphere ( sky, translation([1.0, 2.0, 0.0]) ) ...","title":"Translation"},{"location":"input-file/#rotations","text":"Rotations are always with respect to one of the 3 principal axis. The angle of rotation is expressed in degrees, and the keyword is rotation_^ , where ^ is one of x , y or z , and is the axis along which the rotation occurs. Different basic transformation may be combined into a more complex one with the help of * operator. Since they are implemented as matrices, the order in which transformations are applied is from right to left. In the following example a cube is rotated with respect to the z axis and translated along the x axis by 1.0: ... box ( (-0.5, -0.5, -0.5), (0.5, 0.5, 0.5), minecraft, translation([1.0, 0.0, 0.0]) * rotation_z(30) ) ... On the left the cylinder has been first translated and then rotated. On the right the order of transformations is the opposite","title":"Rotations"},{"location":"input-file/#scaling","text":"The third possible transformation is the one that changes the dimension of the object. The scaling does not have to be homogeneous and may vary along different directions. The keyword is scaling([vec]) , where [vec] components are the scale factor along each direction. ... sphere ( mirror, scaling([1.0, 3.0, 1.0]) ) ... Inhomogeneous scaling of a sphere leads to an ellipsoid","title":"Scaling"},{"location":"input-file/#definitions","text":"One may also want to define a variable that represents a shape, so that this can be called multiple times in the input file with the use of a simple name. This is extremely useful in the creation of complex CSG shapes. The syntax is similar to the one used for defining materials, and to call the object in the file it is sufficient to write the name, and the transformation to apply: ... shape minecraftCube box ( #Defining the shape (-0.5, -0.5, -0.5), (0.5, 0.5, 0.5), minecraft, identity ) minecraftCube ( rotation_z(45) ) #Placing the shape into the world ...","title":"Definitions"},{"location":"input-file/#camera","text":"The last ingredient, before rendering your first image, is a camera from which the world is observed. Cameras accept a transformation parameter that sets its position and orientation. It also need to know the aspect ratio of the image, and the distance from the camera and the scree onto which the scene is projected (recommended is 1.0). There are two different projections available: orthogonal and perspective Orthogonal ... camera( orthogonal, translation([-4,0,1]), 1.0, #Aspect Ratio 1.0 #Distance from screen ) Perspective ... camera( perspective, translation([-4,0,1]), 1.0, 1.0 ) Orthogonal VS Perspective projection. Camera is in the same position for both images","title":"Camera"},{"location":"In-depth/pigments/","text":"Pigments are the objects that describe the color of the different shapes. They are used in BRDF s to specify both the diffuse color and the emitted one. Uniform \u00b6 The simplest pigment available is the uniform one. It is used to make the shapes appear as homogeneously coloured objects. A color is defined by three floats (better if in the range [0, 1]), that describe the three components RBG , within <> . Some of the most common colors can be called also with its HTML name , always included within <> . The list of the available names is updated here . material sky ( diffuse ( uniform(<skyblue>) ), uniform(<skyblue>) ) ... Uniform shapes, ground and sky Image \u00b6 Not all the shapes, though, will be monochromatic. Sometimes something more complex is what you need to make you image appear realistic. For example, colouring a sphere with the map of the world will make it resemble the earth. In this case an image pigment is what you need. You only need to have a PFM file with the image you want to apply to the shape and define your material. material earth ( diffuse ( image ( \"earth.pfm\" ) ), uniform(<black>) ) ... Earth is placed in the universe, both textured with image pigments Procedural Pigments \u00b6 Some kind of pigment can be generated with the help of mathematical functions, the evaluation of which returns the color of each point of the surface of the object. Sometimes, with the help of a pseudo-random noise you can generate very fancy effects! Checkered \u00b6 This is the easiest procedural pigment and is often use in debug process. It produces a texture like the one of a chess board. Of course, you may set the 2 colors of tiles, and their number per side. Usually this pigments makes great grounds, that let you understand better if your world is set as you like. material ground ( diffuse( checkered( <black>, #Color 1 <white>, #Color 2 12 #n of tiles per side ) ), uniform(<black>) ) ... The checkered ground makes the object more visible Marble \u00b6 Thanks to the Perlin noise it is possible to use some functions to evaluate the color of surface points as if the object was made of marble. Since this is an advanced pigment, it is provided also of a default setting that you can use by simply defining the pigment as marble() . Otherwise, you can play with some parameters to custom your marble pigment: c1 Background color of marble (recommended is white) c2 Veining color of marble, you may change this to slightly modify the marble look toward this color xPeriod Number of vertical veining lines yPeriod Number of horizontal veining lines. Together with xPeriod defines the orientation of the stripes turbPower Intensity of the twists to apply to the lines to make veins more realistic octaves Number of octaves summed, more octaves mean blurrier texture (must be a power of 2) Default material marbleMat ( diffuse( marble() ), uniform(<black>) ) Custom material marbleMat ( diffuse( marble( <white>, #c1 <black>, #c2 1.0, #xPeriod 2.0, #yPeriod 3.0, #turbPower 512 #octaves ) ), uniform(<black>) ) Wood \u00b6 With a different repetition of the lines, this time concentric, and with different colors, Perlin noise based texture can be made into wood textures. Once again default setting is provided, but you can customize your wood as you like. Parameters are similar to those of marble , but for the period parameter xyPeriod , that this time is unique, and is the number of circles of wood's vein. Default material woodMat ( diffuse( wood() ), uniform(<black>) ) Custom material woodMat ( diffuse( wood( <darkbrown>, #c1 <black>, #c2 13.0, #xyPeriod 0.15, #turbPower 512 #octaves ) ), uniform(<black>) ) Lava \u00b6 Another available pigment is a lava-like one, with color from reddish brown to yellow. For this pigment too there's the default one. For lava pigment only two parameters are customizable: scale Sets the detail of the noise. Higher value reflects in more detailed noise and therefore into more fragmented lava style. octaves Number of octaves summed, more octaves mean blurrier texture (must be a power of 2) Default material lavaMat ( diffuse( lava() ), uniform(<black>) ) Custom material lavaMat ( diffuse( lava( 4.0, #scale 512 #octaves ) ), uniform(<black>) ) Wood, Marble and Lava pigments","title":"Pigments"},{"location":"In-depth/pigments/#uniform","text":"The simplest pigment available is the uniform one. It is used to make the shapes appear as homogeneously coloured objects. A color is defined by three floats (better if in the range [0, 1]), that describe the three components RBG , within <> . Some of the most common colors can be called also with its HTML name , always included within <> . The list of the available names is updated here . material sky ( diffuse ( uniform(<skyblue>) ), uniform(<skyblue>) ) ... Uniform shapes, ground and sky","title":"Uniform"},{"location":"In-depth/pigments/#image","text":"Not all the shapes, though, will be monochromatic. Sometimes something more complex is what you need to make you image appear realistic. For example, colouring a sphere with the map of the world will make it resemble the earth. In this case an image pigment is what you need. You only need to have a PFM file with the image you want to apply to the shape and define your material. material earth ( diffuse ( image ( \"earth.pfm\" ) ), uniform(<black>) ) ... Earth is placed in the universe, both textured with image pigments","title":"Image"},{"location":"In-depth/pigments/#procedural-pigments","text":"Some kind of pigment can be generated with the help of mathematical functions, the evaluation of which returns the color of each point of the surface of the object. Sometimes, with the help of a pseudo-random noise you can generate very fancy effects!","title":"Procedural Pigments"},{"location":"In-depth/pigments/#checkered","text":"This is the easiest procedural pigment and is often use in debug process. It produces a texture like the one of a chess board. Of course, you may set the 2 colors of tiles, and their number per side. Usually this pigments makes great grounds, that let you understand better if your world is set as you like. material ground ( diffuse( checkered( <black>, #Color 1 <white>, #Color 2 12 #n of tiles per side ) ), uniform(<black>) ) ... The checkered ground makes the object more visible","title":"Checkered"},{"location":"In-depth/pigments/#marble","text":"Thanks to the Perlin noise it is possible to use some functions to evaluate the color of surface points as if the object was made of marble. Since this is an advanced pigment, it is provided also of a default setting that you can use by simply defining the pigment as marble() . Otherwise, you can play with some parameters to custom your marble pigment: c1 Background color of marble (recommended is white) c2 Veining color of marble, you may change this to slightly modify the marble look toward this color xPeriod Number of vertical veining lines yPeriod Number of horizontal veining lines. Together with xPeriod defines the orientation of the stripes turbPower Intensity of the twists to apply to the lines to make veins more realistic octaves Number of octaves summed, more octaves mean blurrier texture (must be a power of 2) Default material marbleMat ( diffuse( marble() ), uniform(<black>) ) Custom material marbleMat ( diffuse( marble( <white>, #c1 <black>, #c2 1.0, #xPeriod 2.0, #yPeriod 3.0, #turbPower 512 #octaves ) ), uniform(<black>) )","title":"Marble"},{"location":"In-depth/pigments/#wood","text":"With a different repetition of the lines, this time concentric, and with different colors, Perlin noise based texture can be made into wood textures. Once again default setting is provided, but you can customize your wood as you like. Parameters are similar to those of marble , but for the period parameter xyPeriod , that this time is unique, and is the number of circles of wood's vein. Default material woodMat ( diffuse( wood() ), uniform(<black>) ) Custom material woodMat ( diffuse( wood( <darkbrown>, #c1 <black>, #c2 13.0, #xyPeriod 0.15, #turbPower 512 #octaves ) ), uniform(<black>) )","title":"Wood"},{"location":"In-depth/pigments/#lava","text":"Another available pigment is a lava-like one, with color from reddish brown to yellow. For this pigment too there's the default one. For lava pigment only two parameters are customizable: scale Sets the detail of the noise. Higher value reflects in more detailed noise and therefore into more fragmented lava style. octaves Number of octaves summed, more octaves mean blurrier texture (must be a power of 2) Default material lavaMat ( diffuse( lava() ), uniform(<black>) ) Custom material lavaMat ( diffuse( lava( 4.0, #scale 512 #octaves ) ), uniform(<black>) ) Wood, Marble and Lava pigments","title":"Lava"},{"location":"In-depth/renderers/","text":"KTracer has three different algorithm that can be used for rendering images. Each one has its pros and cons, let's get a deeper insight of it. On-off \u00b6 This is the most basic (and fast!) algorithm of all. It is mostly use for debug purpose, indeed it only can show 2 colors, distinguishing from pixels where a shape has been hit and point where this did not happen. On-off renderer shows only where shapes are Flat \u00b6 The flat renderer is more realistic than the on-off one still being very fast. It does not let reflections occur, so specular surfaces cannot be rendered. Without reflecting rays, it also does not show any kind of shades, making the image appear a little plain, but it's always bright! Moreover, thanks to its velocity, it's an extremely important tool for having a glance of how the image will be, before launching a lots-of-hour code run for a perfect ray-tracing. No shadows and mirrors are present, but the computation is really fast for Demo! Path Tracer \u00b6 It's the most sophisticated renderer of all. It uses a recursive algorithm to compute the radiance of each pixel following the rendering equation . For this reason, mirrors and shades can be appreciated, but the price to pay is in terms of compute-time. Of course your better images will be performed by this algorithm. So prepare your input file with the other 2 renderers and generate your perfect image with Path Tracer! The computation requires a lot of time and so the image is dark, but one can appreciate all the game of shadows and lights","title":"Renderers"},{"location":"In-depth/renderers/#on-off","text":"This is the most basic (and fast!) algorithm of all. It is mostly use for debug purpose, indeed it only can show 2 colors, distinguishing from pixels where a shape has been hit and point where this did not happen. On-off renderer shows only where shapes are","title":"On-off"},{"location":"In-depth/renderers/#flat","text":"The flat renderer is more realistic than the on-off one still being very fast. It does not let reflections occur, so specular surfaces cannot be rendered. Without reflecting rays, it also does not show any kind of shades, making the image appear a little plain, but it's always bright! Moreover, thanks to its velocity, it's an extremely important tool for having a glance of how the image will be, before launching a lots-of-hour code run for a perfect ray-tracing. No shadows and mirrors are present, but the computation is really fast for Demo!","title":"Flat"},{"location":"In-depth/renderers/#path-tracer","text":"It's the most sophisticated renderer of all. It uses a recursive algorithm to compute the radiance of each pixel following the rendering equation . For this reason, mirrors and shades can be appreciated, but the price to pay is in terms of compute-time. Of course your better images will be performed by this algorithm. So prepare your input file with the other 2 renderers and generate your perfect image with Path Tracer! The computation requires a lot of time and so the image is dark, but one can appreciate all the game of shadows and lights","title":"Path Tracer"},{"location":"In-depth/shapes/","text":"Shapes are the elements that interact with light, building the scene. Everything, from sky to ground to other objects are shapes, that have been eventually transformed and combined to give rise to images. There are some basic shapes available, and more complex can be obtained by CSG constructions. Basic \u00b6 Sphere \u00b6 Sphere is by default the canonical one, with radius=1 and the center in the origin of the axes. Any deformation must be set with a scaling transformation. The only two parameters are the material and the transformation . ... sphere ( sky, scaling([20.0, 20.0, 20.0]) ) ... Plane \u00b6 The plane by default is the xy plane with z=0 . Just like the sphere it accepts a material and a transformation parameter. ... plane ( ground, scaling([20.0, 20.0, 20.0]) ) ... Cylinder \u00b6 Default cylinders are the one with unit radius and unit height, from z=-0.5 to z=0.5 . As for the previous shapes they accept a material and a transformation . ... cylinder ( woodMat, translation([2.0, 0.0, 1.0]) ) ... Box \u00b6 Boxes are a little more complicated. Their dimension are given by the point of minimal value of vertices' coordinates and the maximum one (which are the 2 opposite vertices along one specific diagonal), even though a scaling transformation is always possible. Then the usual material and transformation parameter are accepted. box ( (-0.5, -0.5, -0.5), #Min point (0.5, 0.5, 0.5), #Max point minecraft, identity ) Hyperboloid \u00b6 Hyperboloids are shapes defined by the quadratic equation: x 2 + y 2 - z 2 = 1. The fragment of hyperboloid to be considered, is defined giving the minimum and the maximum values of z accepted. Then the usual material and transformation parameter are accepted. hyperboloid ( -0.5, #Min Z 0.5, #Max Z marble, identity ) CSG \u00b6 Of course the infinite complexity of shapes cannot be captured by only basic shapes. Constructive Solid Geometry (CSG), does not provide a definitive answer to this problem, but offers a powerful tool for combining different basic shapes together, that can be exploited to reach exceptional results. The combination of shapes is based on three logical operations: difference union intersection Remember that shape definitions can be of great help when trying to build a complex CSG object, we recommend to give a look to its documentation in the input file section. Difference \u00b6 Difference is the operation that, given 2 shapes, builds the object where all the point belonging to the first shape and not to the second are considered. In the following example from a box, two other boxes are removed, each with a different rotation, giving birth to a triangular shape. shape baseBox box ( (-0.05, 0.0 , 0.0), (0.05, 1.0 , 1.0), marble, identity ) shape cutBox box ( (-1.0, -3.0 , 0.0), (1.0, 3.0 , 1.0), marble, identity ) shape baseCrossUnit difference( baseBox(identity), cutBox(rotation_x(63), identity ) shape crossUnit difference ( baseCrossUnit(identity), cutBox( translation([0, 1.0, 0]) * rotation_x(-63) ), translation([0, -0.5, -0.5) ) crossUnit(identity) With the difference it is possible to obtain a triangular shape, which will be useful for the top of the final figure Union \u00b6 Union is the operation that combines two shapes into an object resulting from taking all the points of both shapes. It is useful to build together shapes into a unique structure, as in the example. shape base cylinder ( marble, scaling([1.15, 1.15, 0.2]) * translation([0, 0, 0.5]) ) shape base2 union ( base, base ( scaling([0.85, 0.85, 1.5]) * translation([0, 0, 0.2]) ) ) shape body union ( base2, hyperboloid ( 0.5, 0.5, marble, translation([0, 0, 2.0]) * scaling([0.55, 0.55, 3.0]) ) body (identity) With the union some cylinders and an hyperboloid can be built up together Intersection \u00b6 Intersection is the last CSG operation available, and builds the object considering all the points that belong to both the shapes. For example, intersecting a Cylinder and a Sphere will result in: intersection( sphere( marble, scaling([3.0, 3.0, 3.0]) ), cylinder( marble, translation([0, 0, 2.9]) * scaling([0.5, 0.5, 0.2]) ), identity ) Intersection is what we need for the top of our figure And here is the result of a complex CSG object, build up of several combinations, and available in KTracer as a variable of name KTKing . The King of a chess set, with marble procedural texture Advanced CSG \u00b6 Some fascinating shapes have been made available to programmers for their images: KTArmchair A nice armchair for your living room KTKing The most important piece in the chess board If you have some interesting creations, let us know via issues or via e-mail . If you like to share it with the community, we will provide to extend the available shapes.","title":"Shapes"},{"location":"In-depth/shapes/#basic","text":"","title":"Basic"},{"location":"In-depth/shapes/#sphere","text":"Sphere is by default the canonical one, with radius=1 and the center in the origin of the axes. Any deformation must be set with a scaling transformation. The only two parameters are the material and the transformation . ... sphere ( sky, scaling([20.0, 20.0, 20.0]) ) ...","title":"Sphere"},{"location":"In-depth/shapes/#plane","text":"The plane by default is the xy plane with z=0 . Just like the sphere it accepts a material and a transformation parameter. ... plane ( ground, scaling([20.0, 20.0, 20.0]) ) ...","title":"Plane"},{"location":"In-depth/shapes/#cylinder","text":"Default cylinders are the one with unit radius and unit height, from z=-0.5 to z=0.5 . As for the previous shapes they accept a material and a transformation . ... cylinder ( woodMat, translation([2.0, 0.0, 1.0]) ) ...","title":"Cylinder"},{"location":"In-depth/shapes/#box","text":"Boxes are a little more complicated. Their dimension are given by the point of minimal value of vertices' coordinates and the maximum one (which are the 2 opposite vertices along one specific diagonal), even though a scaling transformation is always possible. Then the usual material and transformation parameter are accepted. box ( (-0.5, -0.5, -0.5), #Min point (0.5, 0.5, 0.5), #Max point minecraft, identity )","title":"Box"},{"location":"In-depth/shapes/#hyperboloid","text":"Hyperboloids are shapes defined by the quadratic equation: x 2 + y 2 - z 2 = 1. The fragment of hyperboloid to be considered, is defined giving the minimum and the maximum values of z accepted. Then the usual material and transformation parameter are accepted. hyperboloid ( -0.5, #Min Z 0.5, #Max Z marble, identity )","title":"Hyperboloid"},{"location":"In-depth/shapes/#csg","text":"Of course the infinite complexity of shapes cannot be captured by only basic shapes. Constructive Solid Geometry (CSG), does not provide a definitive answer to this problem, but offers a powerful tool for combining different basic shapes together, that can be exploited to reach exceptional results. The combination of shapes is based on three logical operations: difference union intersection Remember that shape definitions can be of great help when trying to build a complex CSG object, we recommend to give a look to its documentation in the input file section.","title":"CSG"},{"location":"In-depth/shapes/#difference","text":"Difference is the operation that, given 2 shapes, builds the object where all the point belonging to the first shape and not to the second are considered. In the following example from a box, two other boxes are removed, each with a different rotation, giving birth to a triangular shape. shape baseBox box ( (-0.05, 0.0 , 0.0), (0.05, 1.0 , 1.0), marble, identity ) shape cutBox box ( (-1.0, -3.0 , 0.0), (1.0, 3.0 , 1.0), marble, identity ) shape baseCrossUnit difference( baseBox(identity), cutBox(rotation_x(63), identity ) shape crossUnit difference ( baseCrossUnit(identity), cutBox( translation([0, 1.0, 0]) * rotation_x(-63) ), translation([0, -0.5, -0.5) ) crossUnit(identity) With the difference it is possible to obtain a triangular shape, which will be useful for the top of the final figure","title":"Difference"},{"location":"In-depth/shapes/#union","text":"Union is the operation that combines two shapes into an object resulting from taking all the points of both shapes. It is useful to build together shapes into a unique structure, as in the example. shape base cylinder ( marble, scaling([1.15, 1.15, 0.2]) * translation([0, 0, 0.5]) ) shape base2 union ( base, base ( scaling([0.85, 0.85, 1.5]) * translation([0, 0, 0.2]) ) ) shape body union ( base2, hyperboloid ( 0.5, 0.5, marble, translation([0, 0, 2.0]) * scaling([0.55, 0.55, 3.0]) ) body (identity) With the union some cylinders and an hyperboloid can be built up together","title":"Union"},{"location":"In-depth/shapes/#intersection","text":"Intersection is the last CSG operation available, and builds the object considering all the points that belong to both the shapes. For example, intersecting a Cylinder and a Sphere will result in: intersection( sphere( marble, scaling([3.0, 3.0, 3.0]) ), cylinder( marble, translation([0, 0, 2.9]) * scaling([0.5, 0.5, 0.2]) ), identity ) Intersection is what we need for the top of our figure And here is the result of a complex CSG object, build up of several combinations, and available in KTracer as a variable of name KTKing . The King of a chess set, with marble procedural texture","title":"Intersection"},{"location":"In-depth/shapes/#advanced-csg","text":"Some fascinating shapes have been made available to programmers for their images: KTArmchair A nice armchair for your living room KTKing The most important piece in the chess board If you have some interesting creations, let us know via issues or via e-mail . If you like to share it with the community, we will provide to extend the available shapes.","title":"Advanced CSG"}]}